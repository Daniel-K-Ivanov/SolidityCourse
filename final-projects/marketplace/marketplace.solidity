pragma solidity ^0.4.19;

contract Owned {
    address owner;
    
    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }
    
    function Owned () public {
        owner = msg.sender;
    }
}

contract Marketplace is Owned {
    
    struct Product {
        bytes32 id;
        string name;
        uint price;
        uint quantity;
    }
    
    mapping(bytes32 => Product) products;
    bytes32[] ids;
    
    modifier productExists (bytes32 _id) {
        require(products[_id].id == _id);
        _;
    }
    
    event itemPurchaseEvent(address indexed customerAdr, bytes32 indexed itemId, uint quantity);
    event updateQuantityEvent(bytes32 indexed itemId, uint oldQuantity, uint newQuantity);
    
    function Marketplace () public {
    }
    
    function buy(bytes32 _id, uint _quantity) public payable productExists(_id) {
        require(_quantity <= products[_id].quantity);
        
        uint price = getPrice(_id, _quantity);
        require(msg.value >= price);
        
        products[_id].quantity -= _quantity;
        itemPurchaseEvent(msg.sender, _id, _quantity);
    }
    
    function update(bytes32 id, uint _quantity) public onlyOwner productExists(id) {
        uint currentQuantity = products[id].quantity; 
        products[id].quantity = _quantity;
        updateQuantityEvent(id, currentQuantity, _quantity);
    }
    
    //creates new unique ID and a product then returns the ID
    
    function newProduct(string _name, uint _price, uint _quantity) public returns(bytes32) {
        bytes32 generatedID = keccak256(_name, msg.sender);
        if (products[generatedID].id == generatedID) {
            revert();
        }
        
        ids.push(generatedID);
        products[generatedID] = Product({id : generatedID, name : _name, price : _price, quantity : _quantity});
        return generatedID;
    }
    
    //Returns name, price, quantity of a product by id
    
    function getProduct(bytes32 id) public view productExists(id) returns(string name, uint price, uint quantity) {
        return (products[id].name, products[id].price, products[id].quantity);
    }
    
    //Getter for all product ids
    
    function getProducts() public view returns(bytes32[]) {
        return ids;
    }
    
    
    // calculates the price by id and quantity
    // checks for overflow
    
    function getPrice(bytes32 _id, uint _quantity) public view productExists(_id) returns (uint) {
        uint price = products[_id].price * _quantity;
        assert(price / _quantity == products[_id].price);
        
        return price;
    }
    
    //Withdraws the funds from the contract
    
    function withdrawFunds() public onlyOwner {
        owner.transfer(this.balance);
    }
    
}
